
:icons: font
:iconfont-cdn: +https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css

= JavaScript Typescript Graffiti
:doctype: book
:toc:
:toc-placement!:

toc::[]

== Introduction

== Module, Namespace and ... what else?
Starting developing in `node.js` one of the first thing I have met was the `require` keyword used to load a module. Then when I moved to a bit more advanced JavaScript I have met the Revealing Module Pattern, later on with TypeScript I have read about concepts like modules and namespaces.

I am really a bit confusing about what they are and when I should use them, so I will try to find explanation step by step.

=== What is a module and why use modules
*Definition:* a module is a way to encapsulate some piece of code into a unit. The unit can be used by other modules and applications.

*Why:* global variable are evil as discussed [here](http://c2.com/cgi/wiki?GlobalVariablesAreBad) and
[square]
* Clutter up the global namespace and are slower to look up than local variables.
* Forget you declared a variable somewhere and accidentally re-declare it somewhere else (var foo against foo).
* Global variables take longer for Javascript to "find" than local variables, not huge but small performance issue.


=== Where does Module Pattern comes from?
The first guy who talked about the JavaScript Module Pattern was Eric Miraglia (YUI) in a [blog post](http://yuiblog.com/blog/2007/06/12/module-pattern/).

==== IIFE, a fundamental construct
Before talking about *module* I need to introduce a JavaScript [red]#fundamental construct# called IIFE that will enable the module pattern.

The *immediately-invoked function expression (https://en.wikipedia.org/wiki/Immediately-invoked_function_expression[IIFE] /iffy/)* is a JavaScript design pattern to create and immediately invoke an anonymous function.

.Declaration styles
[source, javascript]
----
(function () {
  …
  // access to global variables
})();

(function () {
  …
  // access to global variables
}());  // Douglas Crockford's style
----

.Passing values
[source, javascript]
----
(function (x, y) { … })('foo', 'bar');
----

// todo: explain scope, function declaration vs function expression

==== Implied globals
To see how the pattern is applied we can have a look at AngularJs source code.

.AngularJs partial source code
[source, javascript]
----
(function (window) {
    'use strict';

    ...

    /** @name angular */
    var angular = window.angular || (window.angular = {})

    ...

    publishExternalAPI(angular);

    function publishExternalAPI(angular) {
        extend(angular, {'bootstrap': bootstrap});
    }

    function bootstrap(element, modules, config) {...}
})(window);
----
Some parts of the code has been remove in order to focus on the IIFE. The function is invoked passing the `window` object, inside of the scope a property named `angular` is assign to the `window` object and initialized via the _object literal_ if it does not exist. Once done, the public API is attached to the angular object. Now `angular` framework is globally reachable.

===== How to create a global variables
There are three ways to create a [red]#global variable# in JavaScript and remember we are talking about *global variable*, it will be useful for the next argument.

.Three way to declare a global variable in JavaScript
[source, javascript]
----
window.s = 'felix'    // declare variable s
s = 'felix'           // declare variable s
var s = 'felix'       // declare variable s
----

.Explanation
[TIP]
====
[square]
* *window global:* the variable is directly set on the `window` object. Working in a browser the `window` object is root scope, there is nothing higher than that.
* *implied global:* when an identifier is used, the interpreter resolves it traversing up the [blue]#scope chain# footnote:[More on the scope chain and variable resolution in the David Shariff's post <<identifier-resolution>>.]. If the identifier is not found in the local scope, the global one is involved. If not found a new global variable is created otherwise the old value is updated.
* *declared global:* use `var` reserved keyword to declare a variable. If a local variable and the global variable have the same identifier, the local variable will take the precedence ([red]#shadowing# footnote:[In JavaScript _shadowing_ is a behavior that allows a local variable to take the precedence over the outer or global variable having the same identifier, the inner variable over the outer.]).
====

==== Module export
In the AngularJs example, the `angular` [red]#global object# is created. Sometimes we don't want to create a global object but just [red]#declare#


[appendix]
Variable Scoping and Hoisting
=============================
e

= Bibliography
[bibliography]
.Tutorials
- [[[js-re-introduction]]] link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript[A re-introduction to JavaScript]

.Blog posts
- [[[identifier-resolution]]] link:http://davidshariff.com/blog/javascript-scope-chain-and-closures/[Identifier resolution and closures in the JavaScript scope chain]
- [[[closures]]] link:http://jibbering.com/faq/notes/closures/[Javascript closures]
- [[[learn-closures]]] link:http://ejohn.org/apps/learn/#48[Learn closures]
- [[[learn-advanced-js]]] link:http://ejohn.org/apps/learn/[Learning advanced JavaScript]

.Books
